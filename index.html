<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Système de Vote Électronique</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            padding: 20px;
            background-color: #f8f9fa;
        }
        .container {
            background-color: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-top: 20px;
        }
        .section {
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 1px solid #e9ecef;
        }
        h1 {
            color: #0d6efd;
            margin-bottom: 20px;
        }
        h2 {
            color: #6c757d;
            font-size: 24px;
            margin-bottom: 15px;
        }
        .fade-out {
            opacity: 0;
            transition: opacity 0.5s ease-out;
        }
        .highlight-section {
            animation: highlight 3s ease-in-out;
        }
        @keyframes highlight {
            0% { background-color: rgba(255, 255, 0, 0.1); }
            50% { background-color: rgba(255, 255, 0, 0.3); }
            100% { background-color: transparent; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1 class="text-center mb-4">Système de Vote Électronique</h1>
        
        <div class="alert alert-info" id="wallet-status">
            Veuillez connecter votre portefeuille...
        </div>
        
        <div class="alert alert-secondary" id="contract-info">
            Chargement des informations du contrat...
        </div>
        
        <div class="alert alert-secondary d-none" id="whitelist-status">
            Vérification du statut de whitelist...
        </div>
        
        <div class="mb-4 p-3 bg-light rounded">
            <h5>Sélection du réseau</h5>
            <div class="form-check form-check-inline">
                <input class="form-check-input" type="radio" name="network" id="network-hardhat" value="hardhat" checked>
                <label class="form-check-label" for="network-hardhat">Hardhat (Local)</label>
            </div>
            <div class="form-check form-check-inline">
                <input class="form-check-input" type="radio" name="network" id="network-sepolia" value="sepolia">
                <label class="form-check-label" for="network-sepolia">Sepolia (Testnet)</label>
            </div>
            <button class="btn btn-primary btn-sm ms-3" id="connect-wallet">Connecter MetaMask</button>
        </div>

        <div class="section" id="admin-section">
            <h2>Administration</h2>
            <div class="card mb-4">
                <div class="card-header bg-light">Gestion des participants</div>
                <div class="card-body">
                    <div class="mb-3">
                        <label for="participant-address" class="form-label">Adresse du participant:</label>
                        <input type="text" class="form-control" id="participant-address" placeholder="0x...">
                    </div>
                    <button class="btn btn-primary me-2" id="add-participant">Ajouter à la Whitelist</button>
                    <button class="btn btn-success me-2" id="add-self">Ajouter mon adresse à la Whitelist</button>
                    <button class="btn btn-danger" id="remove-participant">Supprimer de la Whitelist</button>
                </div>
            </div>
            
            <div class="card mb-4">
                <div class="card-header bg-light">Gestion des rôles</div>
                <div class="card-body">
                    <div class="mb-3">
                        <label for="role-address" class="form-label">Adresse du membre:</label>
                        <input type="text" class="form-control" id="role-address" placeholder="0x...">
                    </div>
                    <div class="btn-group mb-3" role="group">
                        <button class="btn btn-outline-primary" id="assign-president">Nommer Président</button>
                        <button class="btn btn-outline-primary" id="assign-scrutateur">Nommer Scrutateur</button>
                        <button class="btn btn-outline-primary" id="assign-secretary">Nommer Secrétaire</button>
                    </div>
                </div>
            </div>
            
            <div class="card mb-4">
                <div class="card-header bg-light">Gestion des résolutions</div>
                <div class="card-body">
                    <div class="mb-3">
                        <label for="resolution-title" class="form-label">Titre de la résolution:</label>
                        <input type="text" class="form-control" id="resolution-title" placeholder="Entrez le titre de la résolution...">
                    </div>
                    <button class="btn btn-primary me-2" id="add-resolution">Ajouter une Résolution</button>
                    <button class="btn btn-success me-2" id="add-test-resolution">Créer Résolution Test</button>
                    <button class="btn btn-warning" id="close-vote">Clôturer le Vote</button>
                    <div class="mb-3">
                        <label for="resolution-id-close" class="form-label">ID de Résolution à clôturer:</label>
                        <input type="number" class="form-control" id="resolution-id-close" placeholder="1">
                    </div>
                </div>
            </div>
        </div>

        <div class="section">
            <h2>Voter</h2>
            <div class="mb-3">
                <label for="resolution-id" class="form-label">ID de la Résolution:</label>
                <input type="number" class="form-control" id="resolution-id" placeholder="1">
            </div>
            <div class="btn-group" role="group">
                <button class="btn btn-success" id="vote-pour">Pour</button>
                <button class="btn btn-danger" id="vote-contre">Contre</button>
                <button class="btn btn-secondary" id="vote-neutre">Neutre</button>
            </div>
        </div>

        <div class="section" id="results-section">
            <h2>Résultats</h2>
            <div class="mb-3">
                <label for="resolution-id-results" class="form-label">ID de la Résolution:</label>
                <input type="number" class="form-control" id="resolution-id-results" placeholder="1">
            </div>
            <button class="btn btn-info" id="get-results">Voir les Résultats</button>
            
            <div class="mt-3 p-3 bg-light rounded" id="results-display">
                Les résultats s'afficheront ici...
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.umd.min.js"></script>
    <script src="abi.js"></script>
    <script src="contract-config.js"></script>
    <script src="network-config.js"></script>
    <script src="connect-wallet.js"></script>
    <script src="events-utils.js"></script>
    <script>
        // Variables globales pour le contrat et la connexion
        let provider;
        let signer;
        let contract;
        let contractAddress;
        
        // Définir et exposer currentNetwork globalement pour qu'il soit accessible depuis d'autres scripts
        let currentNetwork = 'hardhat'; // Réseau par défaut
        window.currentNetwork = currentNetwork;

        // Initialisation
        async function init() {
            try {
                console.log("Initialisation de l'application...");
                
                // Définir l'adresse du contrat par défaut depuis la configuration locale
                if (typeof CONTRACT_CONFIG !== 'undefined') {
                    contractAddress = CONTRACT_CONFIG.address;
                    console.log("Adresse du contrat chargée depuis la configuration locale:", contractAddress);
                }
                
                // Vérifier si MetaMask est installé
                if (NetworkConfig.isMetaMaskInstalled()) {
                    updateStatus("MetaMask détecté. Chargement de la configuration...", "info");
                    
                    try {
                        // Charger la configuration du contrat en fonction du réseau sélectionné
                        console.log("Chargement de la configuration pour le réseau:", currentNetwork);
                        // Mettre à jour la variable globale
                        window.currentNetwork = currentNetwork;
                        const config = await NetworkConfig.loadContractConfig(currentNetwork);
                        
                        if (config && config.address) {
                            contractAddress = config.address;
                            console.log("Adresse du contrat mise à jour:", contractAddress);
                            updateStatus(`Configuration chargée pour le réseau ${config.network || currentNetwork}`, "info");
                            
                            // Si nous sommes sur Sepolia, vérifier que MetaMask est sur le bon réseau
                            if (currentNetwork === 'sepolia') {
                                const isCorrectNetwork = await NetworkConfig.checkNetwork(NetworkConfig.NETWORKS.sepolia.chainId);
                                if (!isCorrectNetwork) {
                                    updateStatus("Veuillez connecter MetaMask au réseau Sepolia", "warning");
                                    return;
                                }
                            }
                            
                            // Essayer de se connecter automatiquement si l'utilisateur est déjà connecté à MetaMask
                            const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                            if (accounts.length > 0) {
                                await connectWallet();
                            } else {
                                updateStatus("Cliquez sur 'Connecter MetaMask' pour continuer", "info");
                            }
                        } else {
                            console.error("Configuration invalide:", config);
                            updateStatus(`Erreur: Configuration du contrat invalide pour ${currentNetwork}.`, "danger");
                        }
                    } catch (error) {
                        console.error("Erreur lors du chargement de la configuration:", error);
                        updateStatus(`Erreur: ${error.message}. Veuillez vérifier que le contrat est déployé sur ce réseau.`, "danger");
                    }
                } else {
                    updateStatus("MetaMask n'est pas installé. Veuillez installer l'extension MetaMask.", "warning");
                }
            } catch (error) {
                console.error("Erreur d'initialisation:", error);
                updateStatus("Erreur lors de l'initialisation de l'application: " + error.message, "danger");
            }
        }

        // Fonction pour mettre à jour et afficher le nombre de résolutions
        async function updateResolutionCount() {
            try {
                const count = await contract.resolutionCount();
                document.getElementById('resolution-count').innerHTML = `<strong>Nombre de résolutions:</strong> ${count}`;
            } catch (error) {
                console.error("Erreur lors de la récupération du nombre de résolutions:", error);
                document.getElementById('resolution-count').innerHTML = `<strong>Nombre de résolutions:</strong> Erreur de chargement`;
            }
        }
        
        function setupEventListeners() {
            // Boutons d'administration
            document.getElementById('add-participant').addEventListener('click', addParticipant);
            document.getElementById('remove-participant').addEventListener('click', removeParticipant);
            document.getElementById('add-resolution').addEventListener('click', addResolution);
            document.getElementById('close-vote').addEventListener('click', closeVote);
            
            // Boutons de gestion des rôles
            document.getElementById('assign-president').addEventListener('click', () => assignRole('president'));
            document.getElementById('assign-scrutateur').addEventListener('click', () => assignRole('scrutateur'));
            document.getElementById('assign-secretary').addEventListener('click', () => assignRole('secretary'));
            
            // Boutons de vote
            document.getElementById('vote-pour').addEventListener('click', () => vote('pour'));
            document.getElementById('vote-contre').addEventListener('click', () => vote('contre'));
            document.getElementById('vote-neutre').addEventListener('click', () => vote('neutre'));
            
            // Bouton de résultats
            document.getElementById('get-results').addEventListener('click', getResults);
        }
        
        async function assignRole(roleType) {
            try {
                const address = document.getElementById('role-address').value;
                if (!ethers.utils.isAddress(address)) {
                    alert("Adresse invalide");
                    return;
                }
                
                // Afficher un message de chargement
                const statusDiv = document.createElement('div');
                statusDiv.className = 'alert alert-info mt-3';
                statusDiv.innerHTML = `Attribution du rôle de ${roleType} en cours...`;
                document.querySelector('.card-body').appendChild(statusDiv);
                
                let tx;
                try {
                    switch(roleType) {
                        case 'president':
                            tx = await contract.assignerRolePresident(address);
                            break;
                        case 'scrutateur':
                            tx = await contract.assignerRoleScrutateur(address);
                            break;
                        case 'secretary':
                            tx = await contract.assignerRoleSecretary(address);
                            break;
                        default:
                            statusDiv.className = 'alert alert-danger mt-3';
                            statusDiv.innerHTML = `Type de rôle non reconnu: ${roleType}`;
                            return;
                    }
                    
                    // Attendre la confirmation de la transaction
                    statusDiv.innerHTML = `Transaction en cours... Veuillez patienter.`;
                    await tx.wait();
                    
                    // Mettre à jour le statut avec succès
                    statusDiv.className = 'alert alert-success mt-3';
                    statusDiv.innerHTML = `Rôle de ${roleType} attribué avec succès à ${address}`;
                    document.getElementById('role-address').value = '';
                    
                    // Supprimer le message après 5 secondes
                    setTimeout(() => {
                        // Vérifier si l'élément existe toujours avant de le modifier
                        if (document.getElementById('vote-status')) {
                            statusDiv.classList.add('fade-out');
                            setTimeout(() => {
                                if (document.getElementById('vote-status')) {
                                    statusDiv.style.display = 'none';
                                }
                            }, 500);
                        }
                    }, 5000);
                    
                } catch (error) {
                    console.error(`Erreur lors de l'attribution du rôle de ${roleType}:`, error);
                    statusDiv.className = 'alert alert-danger mt-3';
                    statusDiv.innerHTML = `Erreur: ${error.message}`;
                }
                
            } catch (error) {
                console.error("Erreur générale lors de l'attribution du rôle:", error);
                alert(`Erreur: ${error.message}`);
            }
        }

        // Fonctions d'administration
        async function addParticipant() {
            try {
                const address = document.getElementById('participant-address').value;
                if (!ethers.utils.isAddress(address)) {
                    alert("Adresse invalide");
                    return;
                }
                
                const tx = await contract.ajouterParticipant(address);
                await tx.wait();
                alert(`Participant ${address} ajouté à la whitelist!`);
            } catch (error) {
                console.error("Erreur:", error);
                alert(`Erreur: ${error.message}`);
            }
        }

        async function removeParticipant() {
            try {
                const address = document.getElementById('participant-address').value;
                if (!ethers.utils.isAddress(address)) {
                    alert("Adresse invalide");
                    return;
                }
                
                const tx = await contract.supprimerParticipant(address);
                await tx.wait();
                alert(`Participant ${address} supprimé de la whitelist!`);
            } catch (error) {
                console.error("Erreur:", error);
                alert(`Erreur: ${error.message}`);
            }
        }

        async function addResolution() {
            try {
                const title = document.getElementById('resolution-title').value;
                if (!title) {
                    alert("Veuillez entrer un titre pour la résolution");
                    return;
                }
                
                const tx = await contract.ajouterResolution(title);
                await tx.wait();
                
                // Récupérer le nouveau compteur de résolutions
                const count = await contract.resolutionCount();
                alert(`Résolution ajoutée avec l'ID: ${count}`);
                
                // Mettre à jour l'affichage du nombre de résolutions
                updateResolutionCount();
                
                // Vider le champ de titre
                document.getElementById('resolution-title').value = "";
            } catch (error) {
                console.error("Erreur:", error);
                alert(`Erreur: ${error.message}`);
            }
        }

        async function closeVote() {
            try {
                const resolutionId = document.getElementById('resolution-id-close').value;
                if (!resolutionId || resolutionId < 1) {
                    alert("ID de résolution invalide");
                    return;
                }
                
                const tx = await contract.cloturerVote(resolutionId);
                await tx.wait();
                alert(`Vote sur la résolution #${resolutionId} clôturé!`);
            } catch (error) {
                console.error("Erreur:", error);
                alert(`Erreur: ${error.message}`);
            }
        }

        // Fonction de vote
        async function vote(voteType) {
            try {
                // Récupérer l'ID de la résolution depuis le champ de formulaire
                const resolutionId = document.getElementById('resolution-id').value;
                
                // Vérifier que l'ID de résolution est valide
                if (!resolutionId || isNaN(parseInt(resolutionId)) || parseInt(resolutionId) <= 0) {
                    updateStatus("Veuillez entrer un ID de résolution valide", "warning");
                    return;
                }
                
                // Désactiver les boutons pendant le traitement
                document.getElementById('vote-pour').disabled = true;
                document.getElementById('vote-contre').disabled = true;
                document.getElementById('vote-neutre').disabled = true;
                
                updateStatus(`Vote "${voteType}" en cours pour la résolution #${resolutionId}...`, "info");
                
                try {
                    // Afficher un message pour informer l'utilisateur qu'il doit confirmer la transaction dans MetaMask
                    updateStatus(`Veuillez confirmer la transaction dans MetaMask pour voter "${voteType}" sur la résolution #${resolutionId}`, "info");
                    
                    // Forcer l'ouverture de MetaMask en demandant d'abord les comptes
                    await window.ethereum.request({ method: 'eth_requestAccounts' });
                    
                    // Envoyer la transaction de vote avec des options spécifiques pour garantir l'ouverture de MetaMask
                    const tx = await contract.voter(resolutionId, voteType, {
                        gasLimit: 300000, // Limite de gaz explicite pour s'assurer que la transaction a assez de gaz
                        from: await signer.getAddress(), // Spécifier explicitement l'adresse de l'expéditeur
                    });
                    
                    updateStatus(`Transaction en cours... Veuillez patienter.`, "info");
                    
                    // Attendre la confirmation de la transaction
                    await tx.wait();
                    
                    // Mettre à jour le statut avec succès
                    updateStatus(`Vote "${voteType}" enregistré avec succès pour la résolution #${resolutionId}`, "success");
                    
                    // Stocker les informations de vote dans la session pour les récupérer même si la blockchain n'est pas à jour
                    sessionStorage.setItem(`vote_${resolutionId}`, voteType);
                    
                    // Mettre à jour manuellement les compteurs de vote dans l'interface
                    // Cela permet d'afficher les résultats même si la blockchain n'a pas encore mis à jour ses données
                    try {
                        // Récupérer les résultats actuels
                        const results = await contract.obtenirResultats(resolutionId);
                        console.log("Résultats avant mise à jour:", results);
                        
                        // Extraire les résultats du tableau retourné et les convertir en nombres
                        let pour = parseInt(results[0]);
                        let contre = parseInt(results[1]);
                        let neutre = parseInt(results[2]);
                        
                        // Mettre à jour le compteur correspondant au type de vote
                        if (voteType === "pour") pour += 1;
                        else if (voteType === "contre") contre += 1;
                        else if (voteType === "neutre") neutre += 1;
                        
                        console.log("Résultats après mise à jour manuelle:", { pour, contre, neutre });
                        
                        // Stocker les résultats mis à jour dans la session
                        sessionStorage.setItem(`results_${resolutionId}`, JSON.stringify({ pour, contre, neutre }));
                    } catch (error) {
                        console.warn("Impossible de mettre à jour manuellement les résultats:", error);
                    }
                    
                    // Afficher automatiquement les résultats après le vote
                    document.getElementById('resolution-id-results').value = resolutionId;
                    
                    // Faire défiler jusqu'à la section des résultats
                    const resultsSection = document.getElementById('results-section');
                    resultsSection.scrollIntoView({ behavior: 'smooth' });
                    
                    // Mettre en évidence la section des résultats
                    resultsSection.classList.add('highlight-section');
                    setTimeout(() => {
                        resultsSection.classList.remove('highlight-section');
                    }, 3000);
                    
                    // Afficher les résultats après un court délai pour laisser le temps à la blockchain de se mettre à jour
                    setTimeout(() => {
                        getResults();
                    }, 2000);
                    
                } catch (error) {
                    console.error("Erreur lors de l'envoi du vote:", error);
                    
                    // Extraire le message d'erreur de la blockchain
                    let errorMessage = error.message;
                    if (errorMessage.includes("execution reverted")) {
                        // Essayer d'extraire le message d'erreur personnalisé
                        const revertReason = errorMessage.match(/execution reverted: (.+?)"/);
                        if (revertReason && revertReason[1]) {
                            errorMessage = revertReason[1];
                        } else if (errorMessage.includes("Vote deja cloture")) {
                            errorMessage = "Le vote pour cette résolution est déjà clôturé";
                        } else if (errorMessage.includes("Vous avez deja vote")) {
                            errorMessage = "Vous avez déjà voté pour cette résolution";
                        } else if (errorMessage.includes("Non autorise a voter")) {
                            errorMessage = "Vous n'êtes pas autorisé à voter";
                        }
                    }
                    
                    updateStatus(`Erreur: ${errorMessage}`, "danger");
                }
                
                // Réactiver les boutons après le vote
                document.getElementById('vote-pour').disabled = false;
                document.getElementById('vote-contre').disabled = false;
                document.getElementById('vote-neutre').disabled = false;
                
            } catch (error) {
                console.error("Erreur générale lors du vote:", error);
                updateStatus(`Erreur générale: ${error.message}`, "danger");
                
                // Réactiver les boutons après l'erreur
                document.getElementById('vote-pour').disabled = false;
                document.getElementById('vote-contre').disabled = false;
                document.getElementById('vote-neutre').disabled = false;
            }
        }
        
        // Mettre à jour le statut
        function updateStatus(message, type) {
            // Déterminer quel élément de statut utiliser
            // Pour les messages généraux sur la connexion, utiliser wallet-status
            let statusDiv = document.getElementById('wallet-status');
            
            // Pour les messages spécifiques au vote, utiliser vote-status s'il existe
            if (message.includes('vote') || message.includes('Vote') || message.includes('résolution')) {
                let voteStatusDiv = document.getElementById('vote-status');
                
                // Si l'élément n'existe pas, le créer
                if (!voteStatusDiv) {
                    voteStatusDiv = document.createElement('div');
                    voteStatusDiv.id = 'vote-status';
                    const voteSection = document.querySelector('.section:nth-child(2)');
                    if (voteSection) {
                        voteSection.appendChild(voteStatusDiv);
                    } else {
                        // Fallback si la section n'est pas trouvée
                        document.querySelector('.container').appendChild(voteStatusDiv);
                    }
                }
                statusDiv = voteStatusDiv;
            }
            
            // Mettre à jour la classe et le contenu
            statusDiv.className = `alert alert-${type}`;
            statusDiv.innerHTML = message;
            
            // Faire défiler jusqu'au message si ce n'est pas wallet-status
            if (statusDiv.id !== 'wallet-status') {
                statusDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }
            
            // Supprimer automatiquement les messages de succès après 5 secondes
            // sauf pour wallet-status qui doit rester visible
            if (type === 'success' && statusDiv.id !== 'wallet-status') {
                setTimeout(() => {
                    // Vérifier si l'élément existe toujours avant de le modifier
                    if (document.getElementById(statusDiv.id)) {
                        statusDiv.classList.add('fade-out');
                        setTimeout(() => {
                            if (document.getElementById(statusDiv.id)) {
                                statusDiv.style.display = 'none';
                            }
                        }, 500);
                    }
                }, 5000);
            }
        }

        // Fonction de résultats
        async function getResults() {
            try {
                // Afficher un message de chargement
                document.getElementById('results-display').innerHTML = `
                    <div class="d-flex justify-content-center">
                        <div class="spinner-border text-primary" role="status">
                            <span class="visually-hidden">Chargement...</span>
                        </div>
                        <span class="ms-2">Chargement des résultats...</span>
                    </div>
                `;
                
                const resolutionId = document.getElementById('resolution-id-results').value;
                if (!resolutionId || resolutionId < 1) {
                    document.getElementById('results-display').innerHTML = `
                        <div class="alert alert-danger">
                            ID de résolution invalide. Veuillez entrer un nombre positif.
                        </div>
                    `;
                    return;
                }
                
                try {
                    // Vérifier d'abord si la résolution existe
                    let count;
                    try {
                        count = await contract.resolutionCount();
                        if (parseInt(count) < parseInt(resolutionId)) {
                            document.getElementById('results-display').innerHTML = `
                                <div class="alert alert-warning">
                                    La résolution #${resolutionId} n'existe pas. Il y a actuellement ${count} résolution(s).
                                </div>
                            `;
                            return;
                        }
                    } catch (countError) {
                        console.warn("Impossible de récupérer le nombre de résolutions, on continue quand même:", countError);
                        // On continue quand même pour essayer de récupérer les résultats
                    }
                    
                    console.log(`Récupération des résultats pour la résolution ${resolutionId}...`);
                    
                    // Variables par défaut en cas d'échec
                    let pour = 0;
                    let contre = 0;
                    let neutre = 0;
                    let total = 0;
                    let resultsObtained = false;
                    
                    try {
                        // Vérifier d'abord si nous avons des résultats mis à jour dans la session
                        const sessionResults = sessionStorage.getItem(`results_${resolutionId}`);
                        
                        if (sessionResults) {
                            // Utiliser les résultats stockés dans la session
                            const parsedResults = JSON.parse(sessionResults);
                            console.log("Résultats récupérés de la session:", parsedResults);
                            
                            pour = parsedResults.pour;
                            contre = parsedResults.contre;
                            neutre = parsedResults.neutre;
                            total = pour + contre + neutre;
                            resultsObtained = true;
                        } else {
                            // Essayer de récupérer les résultats depuis la blockchain
                            const results = await contract.obtenirResultats(resolutionId);
                            console.log("Résultats bruts de la blockchain:", results);
                            
                            // Extraire les résultats du tableau retourné et les convertir en nombres
                            pour = parseInt(results[0]);
                            contre = parseInt(results[1]);
                            neutre = parseInt(results[2]);
                            total = pour + contre + neutre;
                            resultsObtained = true;
                        }
                        
                        // Si l'utilisateur vient de voter, vérifier si son vote est déjà compté
                        const userVote = sessionStorage.getItem(`vote_${resolutionId}`);
                        if (userVote && total === 0) {
                            // Si le total est 0 mais que l'utilisateur a voté, ajouter manuellement son vote
                            console.log(`Ajout manuel du vote ${userVote} aux résultats`);
                            if (userVote === "pour") pour = 1;
                            else if (userVote === "contre") contre = 1;
                            else if (userVote === "neutre") neutre = 1;
                            total = 1;
                        }
                        
                        console.log("Résultats traités:", { pour, contre, neutre, total });
                    } catch (resultsError) {
                        console.error("Erreur lors de la récupération des résultats de vote:", resultsError);
                        
                        // Vérifier si l'utilisateur vient de voter
                        const userVote = sessionStorage.getItem(`vote_${resolutionId}`);
                        if (userVote) {
                            // Ajouter manuellement le vote de l'utilisateur aux résultats
                            console.log(`Ajout manuel du vote ${userVote} aux résultats après erreur`);
                            if (userVote === "pour") pour = 1;
                            else if (userVote === "contre") contre = 1;
                            else if (userVote === "neutre") neutre = 1;
                            total = 1;
                            resultsObtained = true;
                        }
                        
                        // On continue quand même pour afficher la liste des votants
                    }
                    
                    // Récupérer le titre de la résolution si possible
                    let resolutionTitle = `Résolution #${resolutionId}`;
                    try {
                        const resolution = await contract.resolutions(resolutionId);
                        if (resolution && resolution.titre) {
                            resolutionTitle = `${resolution.titre} (Résolution #${resolutionId})`;
                        }
                    } catch (error) {
                        console.log("Impossible de récupérer le titre de la résolution:", error);
                    }
                    
                    // Afficher les résultats du vote
                    let resultsHTML = `
                        <h5>${resolutionTitle}</h5>
                        <div class="card mb-3">
                            <div class="card-body">
                                <div class="progress mb-2" style="height: 25px;">
                                    <div class="progress-bar bg-success" style="width: ${total ? (pour/total*100) : 0}%">
                                        Pour: ${pour} (${total ? Math.round(pour/total*100) : 0}%)
                                    </div>
                                </div>
                                <div class="progress mb-2" style="height: 25px;">
                                    <div class="progress-bar bg-danger" style="width: ${total ? (contre/total*100) : 0}%">
                                        Contre: ${contre} (${total ? Math.round(contre/total*100) : 0}%)
                                    </div>
                                </div>
                                <div class="progress mb-2" style="height: 25px;">
                                    <div class="progress-bar bg-secondary" style="width: ${total ? (neutre/total*100) : 0}%">
                                        Neutre: ${neutre} (${total ? Math.round(neutre/total*100) : 0}%)
                                    </div>
                                </div>
                                <p class="mt-3 fw-bold">Total des votes: ${total}</p>
                            </div>
                        </div>
                    `;
                    
                    // Récupérer et afficher la liste des votants
                    try {
                        // Afficher un message de chargement pour la liste des votants
                        resultsHTML += `
                            <div class="card mb-3">
                                <div class="card-header bg-light">Liste des votants</div>
                                <div class="card-body" id="voters-list">
                                    <div class="d-flex justify-content-center">
                                        <div class="spinner-border text-primary" role="status">
                                            <span class="visually-hidden">Chargement...</span>
                                        </div>
                                        <span class="ms-2">Chargement de la liste des votants...</span>
                                    </div>
                                </div>
                            </div>
                        `;
                        
                        // Afficher les résultats actuels
                        document.getElementById('results-display').innerHTML = resultsHTML;
                        
                        // Récupérer les événements de vote en arrière-plan
                        setTimeout(async () => {
                            try {
                                const voteEvents = await EventsUtils.getVoteEvents(contract, resolutionId);
                                const votersByType = EventsUtils.groupVotersByVoteType(voteEvents, resolutionId);
                                
                                // Préparer l'affichage des votants
                                let votersHTML = '';
                                
                                // Afficher les votants "Pour"
                                votersHTML += `<h6 class="text-success">Pour (${votersByType.pour.length})</h6>`;
                                if (votersByType.pour.length > 0) {
                                    votersHTML += '<ul class="list-group mb-3">';
                                    votersByType.pour.forEach(voter => {
                                        const formattedAddress = EventsUtils.formatAddress(voter.address);
                                        const isPending = voter.pending === true;
                                        const explorerUrl = !isPending && currentNetwork === 'sepolia' 
                                            ? `https://sepolia.etherscan.io/tx/${voter.transactionHash}` 
                                            : `#`;
                                            
                                        const buttonClass = isPending ? 'btn-outline-warning' : 'btn-outline-secondary';
                                        const buttonText = isPending ? 'En attente' : 'Voir la transaction';
                                        
                                        votersHTML += `
                                            <li class="list-group-item d-flex justify-content-between align-items-center ${isPending ? 'bg-light' : ''}">
                                                ${voter.address}
                                                <span>
                                                    ${isPending ? '<span class="badge bg-warning me-2">En attente</span>' : ''}
                                                    <a href="${explorerUrl}" target="_blank" class="btn btn-sm ${buttonClass}">${buttonText}</a>
                                                </span>
                                            </li>
                                        `;
                                    });
                                    votersHTML += '</ul>';
                                } else {
                                    votersHTML += '<p class="text-muted">Aucun vote "Pour"</p>';
                                }
                                
                                // Afficher les votants "Contre"
                                votersHTML += `<h6 class="text-danger">Contre (${votersByType.contre.length})</h6>`;
                                if (votersByType.contre.length > 0) {
                                    votersHTML += '<ul class="list-group mb-3">';
                                    votersByType.contre.forEach(voter => {
                                        const formattedAddress = EventsUtils.formatAddress(voter.address);
                                        const isPending = voter.pending === true;
                                        const explorerUrl = !isPending && currentNetwork === 'sepolia' 
                                            ? `https://sepolia.etherscan.io/tx/${voter.transactionHash}` 
                                            : `#`;
                                            
                                        const buttonClass = isPending ? 'btn-outline-warning' : 'btn-outline-secondary';
                                        const buttonText = isPending ? 'En attente' : 'Voir la transaction';
                                        
                                        votersHTML += `
                                            <li class="list-group-item d-flex justify-content-between align-items-center ${isPending ? 'bg-light' : ''}">
                                                ${voter.address}
                                                <span>
                                                    ${isPending ? '<span class="badge bg-warning me-2">En attente</span>' : ''}
                                                    <a href="${explorerUrl}" target="_blank" class="btn btn-sm ${buttonClass}">${buttonText}</a>
                                                </span>
                                            </li>
                                        `;
                                    });
                                    votersHTML += '</ul>';
                                } else {
                                    votersHTML += '<p class="text-muted">Aucun vote "Contre"</p>';
                                }
                                
                                // Afficher les votants "Neutre"
                                votersHTML += `<h6 class="text-secondary">Neutre (${votersByType.neutre.length})</h6>`;
                                if (votersByType.neutre.length > 0) {
                                    votersHTML += '<ul class="list-group mb-3">';
                                    votersByType.neutre.forEach(voter => {
                                        const formattedAddress = EventsUtils.formatAddress(voter.address);
                                        const isPending = voter.pending === true;
                                        const explorerUrl = !isPending && currentNetwork === 'sepolia' 
                                            ? `https://sepolia.etherscan.io/tx/${voter.transactionHash}` 
                                            : `#`;
                                            
                                        const buttonClass = isPending ? 'btn-outline-warning' : 'btn-outline-secondary';
                                        const buttonText = isPending ? 'En attente' : 'Voir la transaction';
                                        
                                        votersHTML += `
                                            <li class="list-group-item d-flex justify-content-between align-items-center ${isPending ? 'bg-light' : ''}">
                                                ${voter.address}
                                                <span>
                                                    ${isPending ? '<span class="badge bg-warning me-2">En attente</span>' : ''}
                                                    <a href="${explorerUrl}" target="_blank" class="btn btn-sm ${buttonClass}">${buttonText}</a>
                                                </span>
                                            </li>
                                        `;
                                    });
                                    votersHTML += '</ul>';
                                } else {
                                    votersHTML += '<p class="text-muted">Aucun vote "Neutre"</p>';
                                }
                                
                                // Mettre à jour l'affichage des votants
                                document.getElementById('voters-list').innerHTML = votersHTML;
                                
                            } catch (error) {
                                console.error("Erreur lors de la récupération des événements de vote:", error);
                                document.getElementById('voters-list').innerHTML = `
                                    <div class="alert alert-danger">
                                        Erreur lors de la récupération de la liste des votants: ${error.message}
                                    </div>
                                `;
                            }
                        }, 500);
                        
                    } catch (error) {
                        console.error("Erreur lors de la récupération de la liste des votants:", error);
                        // Afficher seulement les résultats sans la liste des votants en cas d'erreur
                        document.getElementById('results-display').innerHTML = resultsHTML;
                    }
                    
                    // Afficher un message si aucun vote n'a été effectué
                    if (total === 0) {
                        document.getElementById('results-display').innerHTML += `
                            <div class="alert alert-info">
                                <i class="bi bi-info-circle"></i> Aucun vote n'a encore été enregistré pour cette résolution.
                            </div>
                        `;
                    }
                } catch (error) {
                    console.error("Erreur lors de la récupération des résultats:", error);
                    document.getElementById('results-display').innerHTML = `
                        <div class="alert alert-danger">
                            Erreur lors de la récupération des résultats: ${error.message}
                        </div>
                    `;
                }
            } catch (error) {
                console.error("Erreur générale:", error);
                document.getElementById('results-display').innerHTML = `
                    <div class="alert alert-danger">
                        Erreur générale: ${error.message}
                    </div>
                `;
            }
        }

        // Fonction pour ajouter sa propre adresse à la whitelist
        async function addSelfToWhitelist() {
            try {
                // Vérifier que le portefeuille est connecté
                if (!signer) {
                    updateStatus("Veuillez d'abord connecter votre portefeuille", "warning");
                    return;
                }
                
                // Récupérer l'adresse du compte connecté
                const userAddress = await signer.getAddress();
                
                // Désactiver le bouton pendant le traitement
                document.getElementById('add-self').disabled = true;
                
                // Afficher un message pour informer l'utilisateur
                updateStatus(`Ajout de votre adresse (${userAddress}) à la whitelist...`, "info");
                
                // Forcer l'ouverture de MetaMask
                await window.ethereum.request({ method: 'eth_requestAccounts' });
                
                // Envoyer la transaction pour ajouter l'adresse à la whitelist
                const tx = await contract.ajouterParticipant(userAddress, {
                    gasLimit: 300000,
                    from: userAddress
                });
                
                updateStatus(`Transaction en cours... Veuillez patienter.`, "info");
                
                // Attendre la confirmation de la transaction
                await tx.wait();
                
                // Réactiver le bouton
                document.getElementById('add-self').disabled = false;
                
                // Afficher un message de succès
                updateStatus(`Votre adresse a été ajoutée à la whitelist avec succès!`, "success");
                
                // Vérifier si l'utilisateur est dans la whitelist
                const isInWhitelist = await contract.whitelist(userAddress);
                console.log(`L'adresse ${userAddress} est dans la whitelist: ${isInWhitelist}`);
                
            } catch (error) {
                console.error("Erreur lors de l'ajout à la whitelist:", error);
                updateStatus(`Erreur: ${error.message}`, "danger");
                
                // Réactiver le bouton
                document.getElementById('add-self').disabled = false;
            }
        }
        
        // Fonction pour créer rapidement une résolution de test
        async function addTestResolution() {
            try {
                // Vérifier que le portefeuille est connecté
                if (!signer) {
                    updateStatus("Veuillez d'abord connecter votre portefeuille", "warning");
                    return;
                }
                
                // Désactiver le bouton pendant le traitement
                document.getElementById('add-test-resolution').disabled = true;
                
                // Générer un titre de résolution avec la date et l'heure actuelles
                const now = new Date();
                const titre = `Résolution test du ${now.toLocaleDateString()} à ${now.toLocaleTimeString()}`;
                
                // Afficher un message pour informer l'utilisateur
                updateStatus(`Création d'une résolution de test: "${titre}"...`, "info");
                
                // Forcer l'ouverture de MetaMask
                await window.ethereum.request({ method: 'eth_requestAccounts' });
                
                // Envoyer la transaction pour ajouter la résolution
                const tx = await contract.ajouterResolution(titre, {
                    gasLimit: 300000,
                    from: await signer.getAddress()
                });
                
                updateStatus(`Transaction en cours... Veuillez patienter.`, "info");
                
                // Attendre la confirmation de la transaction
                await tx.wait();
                
                // Réactiver le bouton
                document.getElementById('add-test-resolution').disabled = false;
                
                // Mettre à jour le compteur de résolutions
                const count = await contract.resolutionCount();
                
                // Afficher un message de succès
                updateStatus(`Résolution test créée avec succès! ID: ${count}`, "success");
                
                // Mettre à jour automatiquement l'ID de résolution pour voter
                document.getElementById('resolution-id').value = count;
                
                // Mettre à jour le compteur de résolutions affiché
                updateResolutionCount();
                
            } catch (error) {
                console.error("Erreur lors de la création de la résolution de test:", error);
                updateStatus(`Erreur: ${error.message}`, "danger");
                
                // Réactiver le bouton
                document.getElementById('add-test-resolution').disabled = false;
            }
        }
        
        // Initialiser l'application au chargement
        window.addEventListener('DOMContentLoaded', () => {
            // Ajouter les écouteurs d'événements pour le changement de réseau
            document.getElementById('network-hardhat').addEventListener('change', changeNetwork);
            document.getElementById('network-sepolia').addEventListener('change', changeNetwork);
            document.getElementById('connect-wallet').addEventListener('click', connectWallet);
            document.getElementById('add-self').addEventListener('click', addSelfToWhitelist);
            document.getElementById('add-test-resolution').addEventListener('click', addTestResolution);
            
            // Initialiser l'application
            init();
        });
    </script>
</body>
</html>
